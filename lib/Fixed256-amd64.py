#!/usr/bin/python3
import sys

def generic_header():
    print(f"""/* Generated by {sys.argv[0]} */

/* Copyright Â© Richard Kettlewell.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <config.h>
""")

def amd64_load(ptr, r):
    assert ptr not in r[:3]
    print(f"  // {r[3]}:{r[2]}:{r[1]}:{r[0]} <- [{ptr}]")
    print(f"  mov {r[0]},[{ptr}]")
    print(f"  mov {r[1]},[{ptr}+8]")
    print(f"  mov {r[2]},[{ptr}+16]")
    print(f"  mov {r[3]},[{ptr}+24]")

def amd64_store(ptr, r):
    print(f"  // [{ptr}] <- {r[3]}:{r[2]}:{r[1]}:{r[0]}")
    print(f"  mov [{ptr}],{r[0]}")
    print(f"  mov [{ptr}+8],{r[1]}")
    print(f"  mov [{ptr}+16],{r[2]}")
    print(f"  mov [{ptr}+24],{r[3]}")

def amd64_neg(r):
    print(f"  // Negate {r[3]}:{r[2]}:{r[1]}:{r[0]}")
    print(f"  not {r[0]}")
    print(f"  not {r[1]}")
    print(f"  not {r[2]}")
    print(f"  not {r[3]}")
    print(f"  add {r[0]},1")
    print(f"  adc {r[1]},0")
    print(f"  adc {r[2]},0")
    print(f"  adc {r[3]},0")

def amd64_header():
    print("""#if __amd64__
.intel_syntax noprefix

#if __linux__
# define SYMBOL(s) s
#else
# define SYMBOL(s) _##s
#endif
""")

def amd64_footer():
    print("""#endif
""")

def amd64_op(op):
    print(f".text")
    print(f".align 16")
    print(f".globl SYMBOL(Fixed256_{op})")
    print(f"SYMBOL(Fixed256_{op}):")
    # rdi = r, rsi = a, rdx = b

    # Register assignment :
    #
    #   rax       mulx input/output
    #   rbx       a[0]
    #   rcx       a[1]
    #   rdx       mulx input/output
    #   rbp       a[2]
    #   rsi       a[3]
    #   rdi       r XOR sign bit (mul only)
    #   r8        r[0]
    #   r9        r[1]
    #   r10       r[2]
    #   r11       r[3]
    # mul only:
    #   r12       b[0]
    #   r13       b[1]
    #   r14       b[2]
    #   r15       b[3]
    #
    # r8-r11 are also used in rotation to calculate the lower words of the product.
    #
    # The treatment of rdi is odd: we know (or assume l-) that as it i an
    # address, it must be even, so we repurpose bit 0 to be the sign of the result.

    a = ["rbx", "rcx", "rbp", "rsi"]
    if op == "mul":
        b = ["r12", "r13", "r14", "r15"]
    else:
        b = a
    r = ["r8", "r9", "r10", "r11"]
    t0 = "rdx"
    t1 = "rax"

    # Registers that we touch
    SMASH = set(a + b + r + [t0, t1])

    # Registers that must be saved
    SAVE = ["rbx", "rbp", "r12", "r13", "r14", "r15"]

    # Limit to those that we touch
    SAVE = [reg for reg in SAVE if reg in SMASH]

    for reg in SAVE:
        print(f"  push {reg}")

    # Normalize inputs and calculate sign
    
    print(f"// Load operands")
    amd64_load("rsi", a)
    if op == "mul":
        amd64_load("rdx", b)
    print(f"// Absolute value of a")
    print(f"  cmp {a[3]},0")
    print(f"  jge 1f")
    amd64_neg(a)
    if op == "mul":
        print(f"  xor rdi,1")
    print(f"1:")
    if op == "mul":
        print(f"// Absolute value of b")
        print(f"  cmp {b[3]},0")
        print(f"  jge 2f")
        amd64_neg(b)
        print(f"  xor rdi,1")
        print(f"2:")

    # We will calculate the full product so we can round correctly
    #
    # We will do 64x64->128 multiplies and use three 64-bit registers
    # to accumulate the sum for each column, including the carry
    # up from previous columns. 
    #
    # We will 'rotate' the accumulator through different registers
    # to achieve this.

    MAXDEPTH=-3
    DEPTH=-3

    assert DEPTH >= MAXDEPTH

    # Moving accumulator
    c = r[-3:] + r + [None, None]

    def row(n, c, add=True):
        cname = ":".join([r for r in reversed(c[:3]) if r != None])
        print(f"// Compute r[{n}] using {cname}")
        assert len(c) == 3
        if c[2] != None:
            print(f"  xor {c[2]},{c[2]}")
        for x in range(0, 4):
            y = n + 3 - x
            if x < 0 or x > 3 or y < 0 or y > 3:
                continue
            if op == "square" and x < y:
                continue
            print(f"  // rdx = a[{x}]")
            print(f"  mov rdx,{a[x]}")
            if add:
                print(f"  // {t1}:{t0} <- a[{x}] * b[{y}]")
                print(f"  mulx {t1},{t0},{b[y]}")
                print(f"  // {cname} += a[{x}] * b[{y}]")
                print(f"  add {c[0]},{t0}")
                if c[1] != None:
                    print(f"  adc {c[1]},{t1}")
                if c[2] != None:
                    print(f"  adc {c[2]},0")
                if op == "square" and x > y:
                    print(f"  // {cname} += a[{y}] * b[{x}]")
                    print(f"  add {c[0]},{t0}")
                    if c[1] != None:
                        print(f"  adc {c[1]},{t1}")
                    if c[2] != None:
                        print(f"  adc {c[2]},0")

            else:
                print(f"  // {c[1]}:{c[0]} <- a[{x}] * b[{y}]")
                print(f"  mulx {c[1]},{c[0]},{b[y]}")
                if op == "square" and x > y:
                    print(f"  // {c[1]}:{c[0]} += a[{y}] * b[{x}]")
                    print(f"  add {c[0]},{c[0]}")
                    print(f"  adc {c[1]},{c[1]}")
                    print(f"  adc {c[2]},{c[2]}")
                add = True

    for i in range(MAXDEPTH, 0):
        if i >= DEPTH:
            row(i, c[:3], i != DEPTH)
        if i == -1:
            print("// Round up")
            print(f"  bt {c[0]},63")
            print(f"  adc {c[1]},0")
            print(f"  adc {c[2]},0")
        # Move the accumulator
        c = c[1:]

    for n in range(0, 4):
        row(n, c[:3])
        # Move the accumulator
        c = c[1:]

    if op == "mul":
        print("// Set sign")
        print("  btr rdi,0")
        print("  jnc 3f")
        amd64_neg(r)
        print("3:")
    print("// Store result")
    amd64_store("rdi", r)

    for reg in reversed(SAVE):
        print(f"  pop {reg}")
    print("  ret")
    print()

generic_header()
amd64_header()
amd64_op("mul")
amd64_op("square")
amd64_footer()
