/* Generated by lib/Fixed256-amd64.py */

/* Copyright Â© Richard Kettlewell.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <config.h>

#if __amd64__
.intel_syntax noprefix

#if __linux__
# define SYMBOL(s) s
#else
# define SYMBOL(s) _##s
#endif

.text
.align 16
.globl SYMBOL(Fixed256_mul)
SYMBOL(Fixed256_mul):
  push rbx
  push rbp
  push r12
  push r13
  push r14
  push r15
// Load operands
  // rsi:rbp:rcx:rbx <- [rsi]
  mov rbx,[rsi]
  mov rcx,[rsi+8]
  mov rbp,[rsi+16]
  mov rsi,[rsi+24]
  // r15:r14:r13:r12 <- [rdx]
  mov r12,[rdx]
  mov r13,[rdx+8]
  mov r14,[rdx+16]
  mov r15,[rdx+24]
// Absolute value of a
  cmp rsi,0
  jge 1f
  // Negate rsi:rbp:rcx:rbx
  not rbx
  not rcx
  not rbp
  not rsi
  add rbx,1
  adc rcx,0
  adc rbp,0
  adc rsi,0
  xor rdi,1
1:
// Absolute value of b
  cmp r15,0
  jge 2f
  // Negate r15:r14:r13:r12
  not r12
  not r13
  not r14
  not r15
  add r12,1
  adc r13,0
  adc r14,0
  adc r15,0
  xor rdi,1
2:
// Compute r[-3] using r11:r10:r9
  xor r11,r11
  // rdx = a[0]
  mov rdx,rbx
  // r10:r9 <- a[0] * b[0]
  mulx r10,r9,r12
// Compute r[-2] using r8:r11:r10
  xor r8,r8
  // rdx = a[0]
  mov rdx,rbx
  // rax:rdx <- a[0] * b[1]
  mulx rax,rdx,r13
  // r8:r11:r10 += a[0] * b[1]
  add r10,rdx
  adc r11,rax
  adc r8,0
  // rdx = a[1]
  mov rdx,rcx
  // rax:rdx <- a[1] * b[0]
  mulx rax,rdx,r12
  // r8:r11:r10 += a[1] * b[0]
  add r10,rdx
  adc r11,rax
  adc r8,0
// Compute r[-1] using r9:r8:r11
  xor r9,r9
  // rdx = a[0]
  mov rdx,rbx
  // rax:rdx <- a[0] * b[2]
  mulx rax,rdx,r14
  // r9:r8:r11 += a[0] * b[2]
  add r11,rdx
  adc r8,rax
  adc r9,0
  // rdx = a[1]
  mov rdx,rcx
  // rax:rdx <- a[1] * b[1]
  mulx rax,rdx,r13
  // r9:r8:r11 += a[1] * b[1]
  add r11,rdx
  adc r8,rax
  adc r9,0
  // rdx = a[2]
  mov rdx,rbp
  // rax:rdx <- a[2] * b[0]
  mulx rax,rdx,r12
  // r9:r8:r11 += a[2] * b[0]
  add r11,rdx
  adc r8,rax
  adc r9,0
// Round up
  bt r11,63
  adc r8,0
  adc r9,0
// Compute r[0] using r10:r9:r8
  xor r10,r10
  // rdx = a[0]
  mov rdx,rbx
  // rax:rdx <- a[0] * b[3]
  mulx rax,rdx,r15
  // r10:r9:r8 += a[0] * b[3]
  add r8,rdx
  adc r9,rax
  adc r10,0
  // rdx = a[1]
  mov rdx,rcx
  // rax:rdx <- a[1] * b[2]
  mulx rax,rdx,r14
  // r10:r9:r8 += a[1] * b[2]
  add r8,rdx
  adc r9,rax
  adc r10,0
  // rdx = a[2]
  mov rdx,rbp
  // rax:rdx <- a[2] * b[1]
  mulx rax,rdx,r13
  // r10:r9:r8 += a[2] * b[1]
  add r8,rdx
  adc r9,rax
  adc r10,0
  // rdx = a[3]
  mov rdx,rsi
  // rax:rdx <- a[3] * b[0]
  mulx rax,rdx,r12
  // r10:r9:r8 += a[3] * b[0]
  add r8,rdx
  adc r9,rax
  adc r10,0
// Compute r[1] using r11:r10:r9
  xor r11,r11
  // rdx = a[1]
  mov rdx,rcx
  // rax:rdx <- a[1] * b[3]
  mulx rax,rdx,r15
  // r11:r10:r9 += a[1] * b[3]
  add r9,rdx
  adc r10,rax
  adc r11,0
  // rdx = a[2]
  mov rdx,rbp
  // rax:rdx <- a[2] * b[2]
  mulx rax,rdx,r14
  // r11:r10:r9 += a[2] * b[2]
  add r9,rdx
  adc r10,rax
  adc r11,0
  // rdx = a[3]
  mov rdx,rsi
  // rax:rdx <- a[3] * b[1]
  mulx rax,rdx,r13
  // r11:r10:r9 += a[3] * b[1]
  add r9,rdx
  adc r10,rax
  adc r11,0
// Compute r[2] using r11:r10
  // rdx = a[2]
  mov rdx,rbp
  // rax:rdx <- a[2] * b[3]
  mulx rax,rdx,r15
  // r11:r10 += a[2] * b[3]
  add r10,rdx
  adc r11,rax
  // rdx = a[3]
  mov rdx,rsi
  // rax:rdx <- a[3] * b[2]
  mulx rax,rdx,r14
  // r11:r10 += a[3] * b[2]
  add r10,rdx
  adc r11,rax
// Compute r[3] using r11
  // rdx = a[3]
  mov rdx,rsi
  // rax:rdx <- a[3] * b[3]
  mulx rax,rdx,r15
  // r11 += a[3] * b[3]
  add r11,rdx
// Set sign
  btr rdi,0
  jnc 3f
  // Negate r11:r10:r9:r8
  not r8
  not r9
  not r10
  not r11
  add r8,1
  adc r9,0
  adc r10,0
  adc r11,0
3:
// Store result
  // [rdi] <- r11:r10:r9:r8
  mov [rdi],r8
  mov [rdi+8],r9
  mov [rdi+16],r10
  mov [rdi+24],r11
  pop r15
  pop r14
  pop r13
  pop r12
  pop rbp
  pop rbx
  ret

.text
.align 16
.globl SYMBOL(Fixed256_square)
SYMBOL(Fixed256_square):
  push rbx
  push rbp
// Load operands
  // rsi:rbp:rcx:rbx <- [rsi]
  mov rbx,[rsi]
  mov rcx,[rsi+8]
  mov rbp,[rsi+16]
  mov rsi,[rsi+24]
// Absolute value of a
  cmp rsi,0
  jge 1f
  // Negate rsi:rbp:rcx:rbx
  not rbx
  not rcx
  not rbp
  not rsi
  add rbx,1
  adc rcx,0
  adc rbp,0
  adc rsi,0
1:
// Compute r[-3] using r11:r10:r9
  xor r11,r11
  // rdx = a[0]
  mov rdx,rbx
  // r10:r9 <- a[0] * b[0]
  mulx r10,r9,rbx
// Compute r[-2] using r8:r11:r10
  xor r8,r8
  // rdx = a[1]
  mov rdx,rcx
  // rax:rdx <- a[1] * b[0]
  mulx rax,rdx,rbx
  // r8:r11:r10 += a[1] * b[0]
  add r10,rdx
  adc r11,rax
  adc r8,0
  // r8:r11:r10 += a[0] * b[1]
  add r10,rdx
  adc r11,rax
  adc r8,0
// Compute r[-1] using r9:r8:r11
  xor r9,r9
  // rdx = a[1]
  mov rdx,rcx
  // rax:rdx <- a[1] * b[1]
  mulx rax,rdx,rcx
  // r9:r8:r11 += a[1] * b[1]
  add r11,rdx
  adc r8,rax
  adc r9,0
  // rdx = a[2]
  mov rdx,rbp
  // rax:rdx <- a[2] * b[0]
  mulx rax,rdx,rbx
  // r9:r8:r11 += a[2] * b[0]
  add r11,rdx
  adc r8,rax
  adc r9,0
  // r9:r8:r11 += a[0] * b[2]
  add r11,rdx
  adc r8,rax
  adc r9,0
// Round up
  bt r11,63
  adc r8,0
  adc r9,0
// Compute r[0] using r10:r9:r8
  xor r10,r10
  // rdx = a[2]
  mov rdx,rbp
  // rax:rdx <- a[2] * b[1]
  mulx rax,rdx,rcx
  // r10:r9:r8 += a[2] * b[1]
  add r8,rdx
  adc r9,rax
  adc r10,0
  // r10:r9:r8 += a[1] * b[2]
  add r8,rdx
  adc r9,rax
  adc r10,0
  // rdx = a[3]
  mov rdx,rsi
  // rax:rdx <- a[3] * b[0]
  mulx rax,rdx,rbx
  // r10:r9:r8 += a[3] * b[0]
  add r8,rdx
  adc r9,rax
  adc r10,0
  // r10:r9:r8 += a[0] * b[3]
  add r8,rdx
  adc r9,rax
  adc r10,0
// Compute r[1] using r11:r10:r9
  xor r11,r11
  // rdx = a[2]
  mov rdx,rbp
  // rax:rdx <- a[2] * b[2]
  mulx rax,rdx,rbp
  // r11:r10:r9 += a[2] * b[2]
  add r9,rdx
  adc r10,rax
  adc r11,0
  // rdx = a[3]
  mov rdx,rsi
  // rax:rdx <- a[3] * b[1]
  mulx rax,rdx,rcx
  // r11:r10:r9 += a[3] * b[1]
  add r9,rdx
  adc r10,rax
  adc r11,0
  // r11:r10:r9 += a[1] * b[3]
  add r9,rdx
  adc r10,rax
  adc r11,0
// Compute r[2] using r11:r10
  // rdx = a[3]
  mov rdx,rsi
  // rax:rdx <- a[3] * b[2]
  mulx rax,rdx,rbp
  // r11:r10 += a[3] * b[2]
  add r10,rdx
  adc r11,rax
  // r11:r10 += a[2] * b[3]
  add r10,rdx
  adc r11,rax
// Compute r[3] using r11
  // rdx = a[3]
  mov rdx,rsi
  // rax:rdx <- a[3] * b[3]
  mulx rax,rdx,rsi
  // r11 += a[3] * b[3]
  add r11,rdx
// Store result
  // [rdi] <- r11:r10:r9:r8
  mov [rdi],r8
  mov [rdi+8],r9
  mov [rdi+16],r10
  mov [rdi+24],r11
  pop rbp
  pop rbx
  ret

#endif

